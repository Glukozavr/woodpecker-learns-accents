-- Player logic

local LEFT = hash("left")
local RIGHT = hash("right")
local JUMP = hash("jump")
local FIRE = hash("fire")

local ANIM_RUN = hash("run")
local ANIM_IDLE = hash("idle")
local ANIM_JUMP = hash("fly-up")
local ANIM_FLY = hash("fly")
local ANIM_FALL = hash("land")

local SPRITE = "visuals#sprite"

local function play_animation(self, anim)
	print("Hello")
	-- only play animations which are not already playing
	if self.anim ~= anim then
		-- tell the sprite to play the animation
		print("Setting anim", anim)
		sprite.play_flipbook(SPRITE, anim)
		-- remember which animation is playing
		self.anim = anim
	end
end

local function update_animations(self)
	-- make sure the player character faces the right way
	sprite.set_hflip(SPRITE, self.direction == -1)

	-- make sure the right animation is playing
	if self.ground_contact then
		if self.velocity.x == 0 then
			play_animation(self, ANIM_IDLE)
		else
			play_animation(self, ANIM_WALK)
		end
	else
		if self.velocity.y > 0 then
			play_animation(self, ANIM_JUMP)
		else
			play_animation(self, ANIM_FALL)
		end
	end
end

function init(self)
	-- this lets us handle input in this script
	msg.post(".", "acquire_input_focus")

	-- activate camera attached to the player collection
	-- this will send camera updates to the render script
	msg.post("#camera", "acquire_camera_focus")
	msg.post("@render:", "use_camera_projection")

	-- spawn position
	self.spawn_position = go.get_position()
	-- the currently playing animation
	self.anim = nil

	play_animation(self, ANIM_IDLE)
end

function on_message(self, message_id, message, sender)
end

function on_input(self, action_id, action)
	if action_id == LEFT then
		-- walk(self, -action.value)
	elseif action_id == RIGHT then
		-- walk(self, action.value)
	elseif action_id == JUMP then
		if action.pressed then
			-- jump(self)
		elseif action.released then
			-- abort_jump(self)
		end
	elseif action_id == FIRE then
		if action.released then
			-- fire(self)
		end
	end
end