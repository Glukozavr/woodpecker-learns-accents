-- Player logic

local LEFT = hash("left")
local RIGHT = hash("right")
local JUMP = hash("jump")
local ATTACK = hash("attack")

local ANIM_RUN = hash("run")
local ANIM_IDLE = hash("idle")
local ANIM_JUMP = hash("fly-up")
local ANIM_FLY = hash("fly")
local ANIM_LAND = hash("land")
local ANIM_ATTACK = hash("attack")

local SPRITE = "visuals#sprite"

-- Body commands and events
local RUN_COMMAND = hash("body_run") -- with value > 0 or < 0
local JUMP_COMMAND = hash("body_jump")
local ABORT_JUMP_COMMAND = hash("body_abort_jump")
local FALL_COMMAND = hash("body_fall")
local BODY_UPDATE = hash("body_update") -- with velocity, ground_contact, wall_contact
local BODY_JUMPED = hash("body_jumped")
local BODY_LANDED = hash("body_landed")
local BODY_FALLING = hash("body_falling")

local function play_animation(self, anim)
	-- only play animations which are not already playing
	if self.anim ~= anim then
		-- tell the sprite to play the animation
		sprite.play_flipbook(SPRITE, anim)
		-- remember which animation is playing
		self.anim = anim
	end
end

local function update_animations(self, body)
	-- make sure the player character faces the right way
	sprite.set_hflip(SPRITE, body.direction == -1)

	-- make sure the right animation is playing
	if body.ground_contact then
		if body.velocity.x == 0 then
			play_animation(self, ANIM_IDLE)
		else
			play_animation(self, ANIM_RUN)
		end
	else
		if self.is_falling then
			play_animation(self, ANIM_ATTACK)
		elseif body.velocity.y > 0 then
			play_animation(self, ANIM_FLY)
		end
	end
end

function init(self)
	-- this lets us handle input in this script
	msg.post(".", "acquire_input_focus")

	-- activate camera attached to the player collection
	-- this will send camera updates to the render script
	msg.post("#camera", "acquire_camera_focus")
	msg.post("@render:", "use_camera_projection")

	-- spawn position
	self.spawn_position = go.get_position()
	-- the currently playing animation
	self.anim = nil
	-- flag to monitor fly state
	self.is_flying = false
	-- flag to monitor falling state
	self.is_falling = false

	play_animation(self, ANIM_IDLE)
end

local function squish()
	--go.animate("visuals", "scale.x", go.PLAYBACK_ONCE_PINGPONG, 0.8, go.EASING_INOUTQUAD, 0.6)
	--go.animate("visuals", "scale.y", go.PLAYBACK_ONCE_PINGPONG, 1.2, go.EASING_INOUTQUAD, 0.6)
end

local function unsquish()
	--go.set("visuals", "scale", 1)
end

function on_message(self, message_id, message, sender)
	if message_id == BODY_UPDATE then
		update_animations(self, message)
		self.is_flying = not message.ground_contact
		if self.is_falling then
			self.is_falling = not message.ground_contact
		end
	elseif message_id == BODY_JUMPED then
		play_animation(self, ANIM_JUMP)
		-- compress and stretch player for visual "juice"
		squish()
	elseif message_id == BODY_LANDED then
		play_animation(self, ANIM_LAND)
		-- reset any "squish" that may have been applied
		unsquish()
	elseif message_id == BODY_FALLING then
		self.is_falling = true
		play_animation(self, ANIM_ATTACK)
	end
end

function on_input(self, action_id, action)
	if action_id == LEFT then
		msg.post(".", RUN_COMMAND, { value = -action.value })
	elseif action_id == RIGHT then
		msg.post(".", RUN_COMMAND, { value = action.value })
	elseif action_id == JUMP then
		if action.pressed then
			msg.post(".", JUMP_COMMAND)
		elseif action.released then
			msg.post(".", ABORT_JUMP_COMMAND)
		end
	elseif action_id == ATTACK and action.pressed and self.is_flying then
		-- attack down only if in the air
		msg.post(".", FALL_COMMAND)
	end
end